{
  "version": 3,
  "sources": ["../index.mjs"],
  "sourcesContent": ["export {\n  LCS,\n  diffComm,\n  diffIndices,\n  diffPatch,\n  diff3MergeRegions,\n  diff3Merge,\n  mergeDiff3,\n  merge,\n  mergeDigIn,\n  patch,\n  stripPatch,\n  invertPatch\n};\n\n\n// Text diff algorithm following Hunt and McIlroy 1976.\n// J. W. Hunt and M. D. McIlroy, An algorithm for differential buffer\n// comparison, Bell Telephone Laboratories CSTR #41 (1976)\n// http://www.cs.dartmouth.edu/~doug/\n// https://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n//\n// Expects two arrays, finds longest common sequence\nfunction LCS(buffer1, buffer2) {\n\n  let equivalenceClasses = {};\n  for (let j = 0; j < buffer2.length; j++) {\n    const item = buffer2[j];\n    if (equivalenceClasses[item]) {\n      equivalenceClasses[item].push(j);\n    } else {\n      equivalenceClasses[item] = [j];\n    }\n  }\n\n  const NULLRESULT = { buffer1index: -1, buffer2index: -1, chain: null };\n  let candidates = [NULLRESULT];\n\n  for (let i = 0; i < buffer1.length; i++) {\n    const item = buffer1[i];\n    const buffer2indices = equivalenceClasses[item] || [];\n    let r = 0;\n    let c = candidates[0];\n\n    for (let jx = 0; jx < buffer2indices.length; jx++) {\n      const j = buffer2indices[jx];\n\n      let s;\n      for (s = r; s < candidates.length; s++) {\n        if ((candidates[s].buffer2index < j) && ((s === candidates.length - 1) || (candidates[s + 1].buffer2index > j))) {\n          break;\n        }\n      }\n\n      if (s < candidates.length) {\n        const newCandidate = { buffer1index: i, buffer2index: j, chain: candidates[s] };\n        if (r === candidates.length) {\n          candidates.push(c);\n        } else {\n          candidates[r] = c;\n        }\n        r = s + 1;\n        c = newCandidate;\n        if (r === candidates.length) {\n          break; // no point in examining further (j)s\n        }\n      }\n    }\n\n    candidates[r] = c;\n  }\n\n  // At this point, we know the LCS: it's in the reverse of the\n  // linked-list through .chain of candidates[candidates.length - 1].\n\n  return candidates[candidates.length - 1];\n}\n\n\n// We apply the LCS to build a 'comm'-style picture of the\n// differences between buffer1 and buffer2.\nfunction diffComm(buffer1, buffer2) {\n  const lcs = LCS(buffer1, buffer2);\n  let result = [];\n  let tail1 = buffer1.length;\n  let tail2 = buffer2.length;\n  let common = {common: []};\n\n  function processCommon() {\n    if (common.common.length) {\n      common.common.reverse();\n      result.push(common);\n      common = {common: []};\n    }\n  }\n\n  for (let candidate = lcs; candidate !== null; candidate = candidate.chain) {\n    let different = {buffer1: [], buffer2: []};\n\n    while (--tail1 > candidate.buffer1index) {\n      different.buffer1.push(buffer1[tail1]);\n    }\n\n    while (--tail2 > candidate.buffer2index) {\n      different.buffer2.push(buffer2[tail2]);\n    }\n\n    if (different.buffer1.length || different.buffer2.length) {\n      processCommon();\n      different.buffer1.reverse();\n      different.buffer2.reverse();\n      result.push(different);\n    }\n\n    if (tail1 >= 0) {\n      common.common.push(buffer1[tail1]);\n    }\n  }\n\n  processCommon();\n\n  result.reverse();\n  return result;\n}\n\n\n// We apply the LCS to give a simple representation of the\n// offsets and lengths of mismatched chunks in the input\n// buffers. This is used by diff3MergeRegions.\nfunction diffIndices(buffer1, buffer2) {\n  const lcs = LCS(buffer1, buffer2);\n  let result = [];\n  let tail1 = buffer1.length;\n  let tail2 = buffer2.length;\n\n  for (let candidate = lcs; candidate !== null; candidate = candidate.chain) {\n    const mismatchLength1 = tail1 - candidate.buffer1index - 1;\n    const mismatchLength2 = tail2 - candidate.buffer2index - 1;\n    tail1 = candidate.buffer1index;\n    tail2 = candidate.buffer2index;\n\n    if (mismatchLength1 || mismatchLength2) {\n      result.push({\n        buffer1: [tail1 + 1, mismatchLength1],\n        buffer1Content: buffer1.slice(tail1 + 1, tail1 + 1 + mismatchLength1),\n        buffer2: [tail2 + 1, mismatchLength2],\n        buffer2Content: buffer2.slice(tail2 + 1, tail2 + 1 + mismatchLength2)\n      });\n    }\n  }\n\n  result.reverse();\n  return result;\n}\n\n\n// We apply the LCS to build a JSON representation of a\n// diff(1)-style patch.\nfunction diffPatch(buffer1, buffer2) {\n  const lcs = LCS(buffer1, buffer2);\n  let result = [];\n  let tail1 = buffer1.length;\n  let tail2 = buffer2.length;\n\n  function chunkDescription(buffer, offset, length) {\n    let chunk = [];\n    for (let i = 0; i < length; i++) {\n      chunk.push(buffer[offset + i]);\n    }\n    return {\n      offset: offset,\n      length: length,\n      chunk: chunk\n    };\n  }\n\n  for (let candidate = lcs; candidate !== null; candidate = candidate.chain) {\n    const mismatchLength1 = tail1 - candidate.buffer1index - 1;\n    const mismatchLength2 = tail2 - candidate.buffer2index - 1;\n    tail1 = candidate.buffer1index;\n    tail2 = candidate.buffer2index;\n\n    if (mismatchLength1 || mismatchLength2) {\n      result.push({\n        buffer1: chunkDescription(buffer1, candidate.buffer1index + 1, mismatchLength1),\n        buffer2: chunkDescription(buffer2, candidate.buffer2index + 1, mismatchLength2)\n      });\n    }\n  }\n\n  result.reverse();\n  return result;\n}\n\n\n// Given three buffers, A, O, and B, where both A and B are\n// independently derived from O, returns a fairly complicated\n// internal representation of merge decisions it's taken. The\n// interested reader may wish to consult\n//\n// Sanjeev Khanna, Keshav Kunal, and Benjamin C. Pierce.\n// 'A Formal Investigation of ' In Arvind and Prasad,\n// editors, Foundations of Software Technology and Theoretical\n// Computer Science (FSTTCS), December 2007.\n//\n// (http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf)\n//\nfunction diff3MergeRegions(a, o, b) {\n\n  // \"hunks\" are array subsets where `a` or `b` are different from `o`\n  // https://www.gnu.org/software/diffutils/manual/html_node/diff3-Hunks.html\n  let hunks = [];\n  function addHunk(h, ab) {\n    hunks.push({\n      ab: ab,\n      oStart: h.buffer1[0],\n      oLength: h.buffer1[1],   // length of o to remove\n      abStart: h.buffer2[0],\n      abLength: h.buffer2[1]   // length of a/b to insert\n      // abContent: (ab === 'a' ? a : b).slice(h.buffer2[0], h.buffer2[0] + h.buffer2[1])\n    });\n  }\n\n  diffIndices(o, a).forEach(item => addHunk(item, 'a'));\n  diffIndices(o, b).forEach(item => addHunk(item, 'b'));\n  hunks.sort((x,y) => x.oStart - y.oStart);\n\n  let results = [];\n  let currOffset = 0;\n\n  function advanceTo(endOffset) {\n    if (endOffset > currOffset) {\n      results.push({\n        stable: true,\n        buffer: 'o',\n        bufferStart: currOffset,\n        bufferLength: endOffset - currOffset,\n        bufferContent: o.slice(currOffset, endOffset)\n      });\n      currOffset = endOffset;\n    }\n  }\n\n  while (hunks.length) {\n    let hunk = hunks.shift();\n    let regionStart = hunk.oStart;\n    let regionEnd = hunk.oStart + hunk.oLength;\n    let regionHunks = [hunk];\n    advanceTo(regionStart);\n\n    // Try to pull next overlapping hunk into this region\n    while (hunks.length) {\n      const nextHunk = hunks[0];\n      const nextHunkStart = nextHunk.oStart;\n      if (nextHunkStart > regionEnd) break;   // no overlap\n\n      regionEnd = Math.max(regionEnd, nextHunkStart + nextHunk.oLength);\n      regionHunks.push(hunks.shift());\n    }\n\n    if (regionHunks.length === 1) {\n      // Only one hunk touches this region, meaning that there is no conflict here.\n      // Either `a` or `b` is inserting into a region of `o` unchanged by the other.\n      if (hunk.abLength > 0) {\n        const buffer = (hunk.ab === 'a' ? a : b);\n        results.push({\n          stable: true,\n          buffer: hunk.ab,\n          bufferStart: hunk.abStart,\n          bufferLength: hunk.abLength,\n          bufferContent: buffer.slice(hunk.abStart, hunk.abStart + hunk.abLength)\n        });\n      }\n    } else {\n      // A true a/b conflict. Determine the bounds involved from `a`, `o`, and `b`.\n      // Effectively merge all the `a` hunks into one giant hunk, then do the\n      // same for the `b` hunks; then, correct for skew in the regions of `o`\n      // that each side changed, and report appropriate spans for the three sides.\n      let bounds = {\n        a: [a.length, -1, o.length, -1],\n        b: [b.length, -1, o.length, -1]\n      };\n      while (regionHunks.length) {\n        hunk = regionHunks.shift();\n        const oStart = hunk.oStart;\n        const oEnd = oStart + hunk.oLength;\n        const abStart = hunk.abStart;\n        const abEnd = abStart + hunk.abLength;\n        let b = bounds[hunk.ab];\n        b[0] = Math.min(abStart, b[0]);\n        b[1] = Math.max(abEnd, b[1]);\n        b[2] = Math.min(oStart, b[2]);\n        b[3] = Math.max(oEnd, b[3]);\n      }\n\n      const aStart = bounds.a[0] + (regionStart - bounds.a[2]);\n      const aEnd = bounds.a[1] + (regionEnd - bounds.a[3]);\n      const bStart = bounds.b[0] + (regionStart - bounds.b[2]);\n      const bEnd = bounds.b[1] + (regionEnd - bounds.b[3]);\n\n      let result = {\n        stable: false,\n        aStart: aStart,\n        aLength: aEnd - aStart,\n        aContent: a.slice(aStart, aEnd),\n        oStart: regionStart,\n        oLength: regionEnd - regionStart,\n        oContent: o.slice(regionStart, regionEnd),\n        bStart: bStart,\n        bLength: bEnd - bStart,\n        bContent: b.slice(bStart, bEnd)\n      };\n      results.push(result);\n    }\n    currOffset = regionEnd;\n  }\n\n  advanceTo(o.length);\n\n  return results;\n}\n\n\n// Applies the output of diff3MergeRegions to actually\n// construct the merged buffer; the returned result alternates\n// between 'ok' and 'conflict' blocks.\n// A \"false conflict\" is where `a` and `b` both change the same from `o`\nfunction diff3Merge(a, o, b, options) {\n  let defaults = {\n    excludeFalseConflicts: true,\n    stringSeparator: /\\s+/\n  };\n  options = Object.assign(defaults, options);\n\n  if (typeof a === 'string') a = a.split(options.stringSeparator);\n  if (typeof o === 'string') o = o.split(options.stringSeparator);\n  if (typeof b === 'string') b = b.split(options.stringSeparator);\n\n  let results = [];\n  const regions = diff3MergeRegions(a, o, b);\n\n  let okBuffer = [];\n  function flushOk() {\n    if (okBuffer.length) {\n      results.push({ ok: okBuffer });\n    }\n    okBuffer = [];\n  }\n\n  function isFalseConflict(a, b) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  regions.forEach(region =>  {\n    if (region.stable) {\n      okBuffer.push(...region.bufferContent);\n    } else {\n      if (options.excludeFalseConflicts && isFalseConflict(region.aContent, region.bContent)) {\n        okBuffer.push(...region.aContent);\n      } else {\n        flushOk();\n        results.push({\n          conflict: {\n            a: region.aContent,\n            aIndex: region.aStart,\n            o: region.oContent,\n            oIndex: region.oStart,\n            b: region.bContent,\n            bIndex: region.bStart\n          }\n        });\n      }\n    }\n  });\n\n  flushOk();\n  return results;\n}\n\n\nfunction mergeDiff3(a, o, b, options) {\n  const defaults = {\n    excludeFalseConflicts: true,\n    stringSeparator: /\\s+/,\n    label: {}\n  };\n  options = Object.assign(defaults, options);\n\n  const aSection = '<<<<<<<' + (options.label.a ? ` ${options.label.a}` : '');\n  const oSection = '|||||||' + (options.label.o ? ` ${options.label.o}` : '');\n  const xSection = '=======';\n  const bSection = '>>>>>>>' + (options.label.b ? ` ${options.label.b}` : '');\n\n  const regions = diff3Merge(a, o, b, options);\n  let conflict = false;\n  let result = [];\n\n  regions.forEach(region => {\n    if (region.ok) {\n      result = result.concat(region.ok);\n    } else if (region.conflict) {\n      conflict = true;\n      result = result.concat(\n        [aSection],\n        region.conflict.a,\n        [oSection],\n        region.conflict.o,\n        [xSection],\n        region.conflict.b,\n        [bSection]\n      );\n    }\n  });\n\n  return {\n    conflict: conflict,\n    result: result\n  };\n}\n\n\nfunction merge(a, o, b, options) {\n  const defaults = {\n    excludeFalseConflicts: true,\n    stringSeparator: /\\s+/,\n    label: {}\n  };\n  options = Object.assign(defaults, options);\n\n  const aSection = '<<<<<<<' + (options.label.a ? ` ${options.label.a}` : '');\n  const xSection = '=======';\n  const bSection = '>>>>>>>' + (options.label.b ? ` ${options.label.b}` : '');\n\n  const regions = diff3Merge(a, o, b, options);\n  let conflict = false;\n  let result = [];\n\n  regions.forEach(region => {\n    if (region.ok) {\n      result = result.concat(region.ok);\n    } else if (region.conflict) {\n      conflict = true;\n      result = result.concat(\n        [aSection],\n        region.conflict.a,\n        [xSection],\n        region.conflict.b,\n        [bSection]\n      );\n    }\n  });\n\n  return {\n    conflict: conflict,\n    result: result\n  };\n}\n\n\nfunction mergeDigIn(a, o, b, options) {\n  const defaults = {\n    excludeFalseConflicts: true,\n    stringSeparator: /\\s+/,\n    label: {}\n  };\n  options = Object.assign(defaults, options);\n\n  const aSection = '<<<<<<<' + (options.label.a ? ` ${options.label.a}` : '');\n  const xSection = '=======';\n  const bSection = '>>>>>>>' + (options.label.b ? ` ${options.label.b}` : '');\n\n  const regions = diff3Merge(a, o, b, options);\n  let conflict = false;\n  let result = [];\n\n  regions.forEach(region => {\n    if (region.ok) {\n      result = result.concat(region.ok);\n    } else {\n      const c = diffComm(region.conflict.a, region.conflict.b);\n      for (let j = 0; j < c.length; j++) {\n        let inner = c[j];\n        if (inner.common) {\n          result = result.concat(inner.common);\n        } else {\n          conflict = true;\n          result = result.concat(\n            [aSection],\n            inner.buffer1,\n            [xSection],\n            inner.buffer2,\n            [bSection]\n          );\n        }\n      }\n    }\n  });\n\n  return {\n    conflict: conflict,\n    result: result\n  };\n}\n\n\n// Applies a patch to a buffer.\n// Given buffer1 and buffer2, `patch(buffer1, diffPatch(buffer1, buffer2))` should give buffer2.\nfunction patch(buffer, patch) {\n  let result = [];\n  let currOffset = 0;\n\n  function advanceTo(targetOffset) {\n    while (currOffset < targetOffset) {\n      result.push(buffer[currOffset]);\n      currOffset++;\n    }\n  }\n\n  for (let chunkIndex = 0; chunkIndex < patch.length; chunkIndex++) {\n    let chunk = patch[chunkIndex];\n    advanceTo(chunk.buffer1.offset);\n    for (let itemIndex = 0; itemIndex < chunk.buffer2.chunk.length; itemIndex++) {\n      result.push(chunk.buffer2.chunk[itemIndex]);\n    }\n    currOffset += chunk.buffer1.length;\n  }\n\n  advanceTo(buffer.length);\n  return result;\n}\n\n\n// Takes the output of diffPatch(), and removes extra information from it.\n// It can still be used by patch(), below, but can no longer be inverted.\nfunction stripPatch(patch) {\n  return patch.map(chunk => ({\n    buffer1: { offset: chunk.buffer1.offset, length: chunk.buffer1.length },\n    buffer2: { chunk: chunk.buffer2.chunk }\n  }));\n}\n\n\n// Takes the output of diffPatch(), and inverts the sense of it, so that it\n// can be applied to buffer2 to give buffer1 rather than the other way around.\nfunction invertPatch(patch) {\n  return patch.map(chunk => ({\n    buffer1: chunk.buffer2,\n    buffer2: chunk.buffer1\n  }));\n}\n"],
  "mappings": "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",
  "names": []
}
